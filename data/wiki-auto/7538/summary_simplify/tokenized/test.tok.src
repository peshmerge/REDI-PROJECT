[CLS] a checks ##um is a small - sized dat ##um derived from a block of digital data for the purpose of detecting errors that may have been introduced during its transmission or storage . [SEP]
[CLS] by themselves , checks ##ums are often used to verify data integrity but are not relied upon to verify data authenticity . [SEP]
[CLS] this is especially true of crypt ##ographic hash functions , which may be used to detect many data corruption errors and verify overall data integrity ; if the computed checks ##um for the current data input matches the stored value of a previously computed checks ##um , there is a very high probability the data has not been accidentally altered or corrupted . [SEP]
[CLS] for instance , a function returning the start of a string can provide a hash appropriate for some applications but will never be a suitable checks ##um . [SEP]
[CLS] some error - correct ##ing codes are based on special checks ##ums which not only detect common errors but also allow the original data to be recovered in certain cases . [SEP]
[CLS] the simplest checks ##um algorithm is the so - called longitudinal par ##ity check , which breaks the data into " words " with a fixed number " n " of bits , and then compute ##s the exclusive or ( x ##or ) of all those words . [SEP]
[CLS] to check the integrity of a message , the receiver compute ##s the exclusive or of all its words , including the checks ##um ; if the result is not a word consisting of " n " zero ##s , the receiver knows a transmission error occurred . [SEP]
[CLS] with this checks ##um , any transmission error which flip ##s a single bit of the message , or an odd number of bits , will be detected as an incorrect checks ##um . [SEP]
[CLS] however , an error which affects two bits will not be detected if those bits lie at the same position in two distinct words . [SEP]
[CLS] a variant of the previous algorithm is to add all the " words " as unsigned binary numbers , disc ##arding any over ##flow bits , and app ##end the two ' s complement of the total as the checks ##um . [SEP]
[CLS] to valid ##ate a message , the receiver adds all the words in the same manner , including the checks ##um ; if the result is not a word full of zero ##s , an error must have occurred . [SEP]
[CLS] the simple checks ##ums described above fail to detect some common errors which affect many bits at once , such as changing the order of data words , or insert ##ing or del ##eti ##ng words with all bits set to zero . [SEP]
[CLS] the checks ##um algorithms most used in practice , such as fletcher ' s checks ##um , adler - 32 , and cyclic red ##unda ##ncy checks ( cr ##cs ) , address these weaknesses by considering not only the value of each word but also its position in the sequence . [SEP]
[CLS] a message that is " m " bits long can be viewed as a corner of the " m " - dimensional hyper ##cu ##be . [SEP]
[CLS] the effect of a checks ##um algorithm that yields an n - bit checks ##um is to map each " m " - bit message to a corner of a larger hyper ##cu ##be , with dimension . [SEP]
[CLS] a single - bit transmission error then corresponds to a displacement from a valid corner ( the correct message and checks ##um ) to one of the " m " adjacent corners . [SEP]
[CLS] the goal of a good checks ##um algorithm is to spread the valid corners as far from each other as possible , so as to increase the likelihood " typical " transmission errors will end up in an invalid corner . [SEP]
