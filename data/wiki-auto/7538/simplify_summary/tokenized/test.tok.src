[CLS] a checks ##um is a small - sized dat ##um derived from a block of digital data for the purpose of detecting errors that may have been introduced during its transmission or storage . [SEP]
[CLS] it is usually applied to an installation file after it is received from the download server . [SEP]
[CLS] by themselves , checks ##ums are often used to verify data integrity but are not relied upon to verify data authenticity . [SEP]
[CLS] the actual procedure which yields the checks ##um from a data input is called a checks ##um function or checks ##um algorithm . [SEP]
[CLS] depending on its design goals , a good checks ##um algorithm will usually output a significantly different value , even for small changes made to the input . [SEP]
[CLS] this is especially true of crypt ##ographic hash functions , which may be used to detect many data corruption errors and verify overall data integrity ; if the computed checks ##um for the current data input matches the stored value of a previously computed checks ##um , there is a very high probability the data has not been accidentally altered or corrupted . [SEP]
[CLS] checks ##um functions are related to hash functions , fingerprints , random ##ization functions , and crypt ##ographic hash functions . [SEP]
[CLS] however , each of those concepts has different applications and therefore different design goals . [SEP]
[CLS] for instance , a function returning the start of a string can provide a hash appropriate for some applications but will never be a suitable checks ##um . [SEP]
[CLS] checks ##ums are used as crypt ##ographic primitive ##s in larger authentication algorithms . [SEP]
[CLS] for crypt ##ographic systems with these two specific design goals , see hm ##ac . [SEP]
[CLS] check digits and par ##ity bits are special cases of checks ##ums , appropriate for small blocks of data ( such as social security numbers , bank account numbers , computer words , single bytes , etc . ) . [SEP]
[CLS] some error - correct ##ing codes are based on special checks ##ums which not only detect common errors but also allow the original data to be recovered in certain cases . [SEP]
[CLS] the simplest checks ##um algorithm is the so - called longitudinal par ##ity check , which breaks the data into " words " with a fixed number " n " of bits , and then compute ##s the exclusive or ( x ##or ) of all those words . [SEP]
[CLS] the result is app ##ended to the message as an extra word . [SEP]
[CLS] to check the integrity of a message , the receiver compute ##s the exclusive or of all its words , including the checks ##um ; if the result is not a word consisting of " n " zero ##s , the receiver knows a transmission error occurred . [SEP]
[CLS] with this checks ##um , any transmission error which flip ##s a single bit of the message , or an odd number of bits , will be detected as an incorrect checks ##um . [SEP]
[CLS] however , an error which affects two bits will not be detected if those bits lie at the same position in two distinct words . [SEP]
[CLS] also swap ##ping of two or more words will not be detected . [SEP]
[CLS] if the affected bits are independently chosen at random , the probability of a two - bit error being und ##ete ##cted is 1 / " n " . [SEP]
[CLS] a variant of the previous algorithm is to add all the " words " as unsigned binary numbers , disc ##arding any over ##flow bits , and app ##end the two ' s complement of the total as the checks ##um . [SEP]
[CLS] to valid ##ate a message , the receiver adds all the words in the same manner , including the checks ##um ; if the result is not a word full of zero ##s , an error must have occurred . [SEP]
[CLS] this variant too detect ##s any single - bit error , but the promo ##du ##lar sum is used in sa ##e j ##17 ##0 ##8 . [SEP]
[CLS] the simple checks ##ums described above fail to detect some common errors which affect many bits at once , such as changing the order of data words , or insert ##ing or del ##eti ##ng words with all bits set to zero . [SEP]
[CLS] the checks ##um algorithms most used in practice , such as fletcher ' s checks ##um , adler - 32 , and cyclic red ##unda ##ncy checks ( cr ##cs ) , address these weaknesses by considering not only the value of each word but also its position in the sequence . [SEP]
[CLS] this feature generally increases the cost of computing the checks ##um . [SEP]
[CLS] a message that is " m " bits long can be viewed as a corner of the " m " - dimensional hyper ##cu ##be . [SEP]
[CLS] the effect of a checks ##um algorithm that yields an n - bit checks ##um is to map each " m " - bit message to a corner of a larger hyper ##cu ##be , with dimension . [SEP]
[CLS] the 2 corners of this hyper ##cu ##be represent all possible received messages . [SEP]
[CLS] the valid received messages ( those that have the correct checks ##um ) comprise a smaller set , with only 2 corners . [SEP]
[CLS] a single - bit transmission error then corresponds to a displacement from a valid corner ( the correct message and checks ##um ) to one of the " m " adjacent corners . [SEP]
[CLS] an error which affects " k " bits moves the message to a corner which is " k " steps removed from its correct corner . [SEP]
[CLS] the goal of a good checks ##um algorithm is to spread the valid corners as far from each other as possible , so as to increase the likelihood " typical " transmission errors will end up in an invalid corner . [SEP]
