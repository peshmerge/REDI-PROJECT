[CLS] computer programming is the process of designing and building an ex ##ec ##utable computer program for accomplish ##ing a specific computing task . [SEP]
[CLS] programming involves tasks such as : analysis , generating algorithms , prof ##iling algorithms ' accuracy and resource consumption , and the implementation of algorithms in a chosen programming language ( commonly referred to as coding ) . [SEP]
[CLS] the source code of a program is written in one or more languages that are intel ##li ##gible to programmers , rather than machine code , which is directly executed by the central processing unit . [SEP]
[CLS] the purpose of programming is to find a sequence of instructions that will auto ##mate the performance of a task ( which can be as complex as an operating system ) on a computer , often for solving a given problem . [SEP]
[CLS] the process of programming thus often requires expertise in several different subjects , including knowledge of the application domain , specialized algorithms , and formal logic . [SEP]
[CLS] tasks accompanying and related to programming include : testing , de ##bu ##gging , source code maintenance , implementation of build systems , and management of derived artifacts , such as the machine code of computer programs . [SEP]
[CLS] these might be considered part of the programming process , but often the term " software development " is used for this larger process with the term " programming " , " implementation " , or " coding " reserved for the actual writing of code . [SEP]
[CLS] " software engineering " combines engineering techniques with software development practices . [SEP]
[CLS] " reverse engineering " is the opposite process . [SEP]
[CLS] a " hacker " is any skilled computer expert that uses their technical knowledge to overcome a problem , but it can also mean a " security hacker " in common language . [SEP]
[CLS] program ##mable devices have existed at least as far back as 120 ##6 ad , when the auto ##mata of al - ja ##zar ##i were program ##mable , via peg ##s and cam ##s , to play various rhythms and drum patterns ; and the 1801 ja ##c ##qua ##rd lo ##om could produce entirely different weave ##s by changing the " program " - a series of paste ##board cards with holes punched in them . [SEP]
[CLS] however , the first computer program is generally dated to 1843 , when mathematician ada love ##lace published an algorithm to calculate a sequence of bern ##ou ##lli numbers , intended to be carried out by charles ba ##bba ##ge ' s analytical engine . [SEP]
[CLS] in the 1880s herman ho ##ller ##ith invented the concept of storing " data " in machine - read ##able form . [SEP]
[CLS] later a control panel ( plug ##board ) added to his 1906 type i tab ##ulator allowed it to be programmed for different jobs , and by the late 1940s , unit record equipment such as the ibm 60 ##2 and ibm 60 ##4 , were programmed by control panels in a similar way ; as were the first electronic computers . [SEP]
[CLS] however , with the concept of the stored - program computers introduced in 1949 , both programs and data were stored and manipulated in the same way in computer memory . [SEP]
[CLS] machine code was the language of early programs , written in the instruction set of the particular machine , often in binary notation . [SEP]
[CLS] assembly languages were soon developed that let the programmer specify instruction in a text format , ( e . g . , add x , total ) , with abbreviation ##s for each operation code and meaningful names for specify ##ing addresses . [SEP]
[CLS] however , because an assembly language is little more than a different notation for a machine language , any two machines with different instruction sets also have different assembly languages . [SEP]
[CLS] high - level languages made the process of developing a program simpler and more understand ##able , and less bound to the underlying hardware . [SEP]
[CLS] fort ##ran , the first widely used high - level language to have a functional implementation , came out in 1957 and many other languages were soon developed â€“ in particular , co ##bol aimed at commercial data processing , and li ##sp for computer research . [SEP]
[CLS] programs were mostly still entered using punched cards or paper tape . [SEP]
[CLS] see computer programming in the punch card era . [SEP]
[CLS] by the late 1960s , data storage devices and computer terminals became inexpensive enough that programs could be created by typing directly into the computers . [SEP]
[CLS] text editors were developed that allowed changes and corrections to be made much more easily than with punched cards . [SEP]
[CLS] whatever the approach to development may be , the final program must satisfy some fundamental properties . [SEP]
[CLS] in computer programming , read ##ability refers to the ease with which a human reader can comprehend the purpose , control flow , and operation of source code . [SEP]
[CLS] it affects the aspects of quality above , including port ##ability , usa ##bility and most importantly maintain ##ability . [SEP]
[CLS] read ##ability is important because programmers spend the majority of their time reading , trying to understand and modifying existing source code , rather than writing new source code . [SEP]
[CLS] un ##rea ##dable code often leads to bugs , in ##ef ##fi ##cie ##ncies , and duplicate ##d code . [SEP]
[CLS] a study found that a few simple read ##ability transformations made code shorter and drastically reduced the time to understand it . [SEP]
[CLS] following a consistent programming style often helps read ##ability . [SEP]
[CLS] however , read ##ability is more than just programming style . [SEP]
[CLS] many factors , having little or nothing to do with the ability of the computer to efficiently com ##pile and execute the code , contribute to read ##ability . [SEP]
[CLS] the presentation aspects of this ( such as ind ##ents , line breaks , color highlighting , and so on ) are often handled by the source code editor , but the content aspects reflect the programmer ' s talent and skills . [SEP]
[CLS] various visual programming languages have also been developed with the intent to resolve read ##ability concerns by adopting non - traditional approaches to code structure and display . [SEP]
[CLS] integrated development environments ( id ##es ) aim to integrate all such help . [SEP]
[CLS] techniques like code ref ##act ##orin ##g can enhance read ##ability . [SEP]
[CLS] the academic field and the engineering practice of computer programming are both largely concerned with discovering and implementing the most efficient algorithms for a given class of problem . [SEP]
[CLS] for this purpose , algorithms are classified into " orders " using so - called big o notation , which expresses resource use , such as execution time or memory consumption , in terms of the size of an input . [SEP]
[CLS] expert programmers are familiar with a variety of well - established algorithms and their respective complex ##ities and use this knowledge to choose algorithms that are best suited to the circumstances . [SEP]
[CLS] " programming a computer for playing chess " was a 1950 paper that evaluated a " mini ##max " algorithm that is part of the history of algorithm ##ic complexity ; a course on ibm ' s deep blue ( chess computer ) is part of the computer science curriculum at stanford university . [SEP]
[CLS] the first step in most formal software development processes is requirements analysis , followed by testing to determine value modeling , implementation , and failure elimination ( de ##bu ##gging ) . [SEP]
[CLS] there exist a lot of differing approaches for each of those tasks . [SEP]
[CLS] one approach popular for requirements analysis is use case analysis . [SEP]
[CLS] many programmers use forms of agile software development where the various stages of formal software development are more integrated together into short cycles that take a few weeks rather than years . [SEP]
[CLS] there are many approaches to the software development process . [SEP]
[CLS] popular modeling techniques include object - oriented analysis and design ( o ##oa ##d ) and model - driven architecture ( md ##a ) . [SEP]
[CLS] the unified modeling language ( um ##l ) is a notation used for both the o ##oa ##d and md ##a . [SEP]
[CLS] a similar technique used for database design is entity - relationship modeling ( er modeling ) . [SEP]
[CLS] implementation techniques include imperative languages ( object - oriented or procedural ) , functional languages , and logic languages . [SEP]
[CLS] it is very difficult to determine what are the most popular of modern programming languages . [SEP]
[CLS] methods of measuring programming language popularity include : counting the number of job advertisements that mention the language , the number of books sold and courses teaching the language ( this over ##est ##imate ##s the importance of newer languages ) , and estimates of the number of existing lines of code written in the language ( this under ##est ##imate ##s the number of users of business languages such as co ##bol ) . [SEP]
[CLS] some languages are very popular for particular kinds of applications , while some languages are regularly used to write many different kinds of applications . [SEP]
[CLS] for example , co ##bol is still strong in corporate data centers often on large main ##frame computers , fort ##ran in engineering applications , script ##ing languages in web development , and c in embedded software . [SEP]
[CLS] many applications use a mix of several languages in their construction and use . [SEP]
[CLS] new languages are generally designed around the syntax of a prior language with new functionality added , ( for example c + + adds object - orientation to c , and java adds memory management and byte ##code to c + + , but as a result , loses efficiency and the ability for low - level manipulation ) . [SEP]
[CLS] de ##bu ##gging is a very important task in the software development process since having defects in a program can have significant consequences for its users . [SEP]
[CLS] some languages are more prone to some kinds of faults because their specification does not require compiler ##s to perform as much checking as other languages . [SEP]
[CLS] use of a static code analysis tool can help detect some possible problems . [SEP]
[CLS] normally the first step in de ##bu ##gging is to attempt to reproduce the problem . [SEP]
[CLS] this can be a non - trivial task , for example as with parallel processes or some unusual software bugs . [SEP]
[CLS] also , specific user environment and usage history can make it difficult to reproduce the problem . [SEP]
[CLS] after the bug is reproduced , the input of the program may need to be simplified to make it easier to de ##bu ##g . [SEP]
[CLS] for example , a bug in a compiler can make it crash when par ##sing some large source file . [SEP]
[CLS] however , after sim ##pl ##ification of the test case , only few lines from the original source file can be sufficient to reproduce the same crash . [SEP]
[CLS] such sim ##pl ##ification can be done manually , using a divide - and - conquer approach . [SEP]
[CLS] the programmer will try to remove some parts of original test case and check if the problem still exists . [SEP]
[CLS] when de ##bu ##gging the problem in a gui , the programmer can try to skip some user interaction from the original problem description and check if remaining actions are sufficient for bugs to appear . [SEP]
[CLS] de ##bu ##gging is often done with id ##es like eclipse , visual studio , x ##code , k ##dev ##elo ##p , net ##be ##ans and . [SEP]
[CLS] standalone de ##bu ##gger ##s like g ##db are also used , and these often provide less of a visual environment , usually using a command line . [SEP]
[CLS] some text editors such as em ##ac ##s allow g ##db to be invoked through them , to provide a visual environment . [SEP]
[CLS] different programming languages support different styles of programming ( called " programming paradigm ##s " ) . [SEP]
[CLS] the choice of language used is subject to many considerations , such as company policy , suit ##ability to task , availability of third - party packages , or individual preference . [SEP]
[CLS] ideally , the programming language best suited for the task at hand will be selected . [SEP]
[CLS] trade - offs from this ideal involve finding enough programmers who know the language to build a team , the availability of compiler ##s for that language , and the efficiency with which programs written in a given language execute . [SEP]
[CLS] languages form an approximate spectrum from " low - level " to " high - level " ; " low - level " languages are typically more machine - oriented and faster to execute , whereas " high - level " languages are more abstract and easier to use but execute less quickly . [SEP]
[CLS] it is usually easier to code in " high - level " languages than in " low - level " ones . [SEP]
[CLS] many computer languages provide a mechanism to call functions provided by shared libraries . [SEP]
[CLS] provided the functions in a library follow the appropriate run - time conventions ( e . g . , method of passing arguments ) , then these functions may be written in any other language . [SEP]
[CLS] computer programmers are those who write computer software . [SEP]
